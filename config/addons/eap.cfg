# Include servo hardware definition separately to allow for automatic upgrade
[include eap_hw.cfg]


# Ejection Assisted Purge (EAP).
# Macros for Klipper.
# BRUSH
# PURGE
# PURGE_HOME
# PURGE_EJECT

[gcode_macro _PURGE_CFG]
# A central place for the configuration of all the macros in this file.
gcode:

############################################################################################################# 
### Brushing.

# X,Y start position. A few mm past the right side of the brush.
variable_brush_start: 131, 348.2

# X stroke relative to the start. A few mm past the left of the brush.
variable_brush_stroke: -40

# X distance relative to the start position to clear away from the brush.
variable_brush_clear: 15

# Brushing speed in mm/s.
variable_brush_speed: 350

# How many times to brush.
variable_brush_count: 4

############################################################################################################# 
### Purging.
#
# X, Y start position of the purging groove. A bit on right side of the end of
# the piston.
variable_groove_start: 54, 348.2

# Position relative to the start of the grove where to wait for cooling and
# ejection.
variable_cooling_pos: 15, -6

# Minimum cooling time in seconds. If less than the cooling time has elapsed,
# the next purge will wait for the end of the cooling period with the cooling
# fan atop.
variable_cooling_period: 15

# Default purging amount in mm³.
variable_volume: 140

# The absolute minimum to purge, even if you don't changed tools. This is to prime the 
# nozzle before printing
variable_purge_length_minimum: 60

# The slicer values often are a bit too wastefull. Tune it here to get optimal values. 0.6
# is a good starting point.
variable_purge_length_modifier: 0.5

# Length of filament to add after the purge volume. Purge volumes don't always take 
# cutters into account and therefor a swap from red to white might be long enough, but 
# from white to red can be far too short. When should you alter this value:
#   INCREASE: When the dark to light swaps are good, but light to dark aren't.
#   DECREASE: When the light to dark swaps are good, but dark to light aren't. Don't 
#     forget to increase the purge_length_modifier
variable_purge_length_addition: 30

# Default purging flow rate in mm³/s. Depends on the hotend, extruder, and
# viscocity of the plastic.
variable_flowrate: 20

# After a purge at a high flow rate, some pressure is left in the nozzle.
# A bit of retraction can even it out. Volume in mm³.
variable_retraction: 5.

# Retraction speed in mm/s.
variable_retraction_speed: 35

# Length of the groove relative (X) to the start.
variable_groove_len: 35

# Filament crosssection area in mm².
variable_fil_csa: 2.405 # 1.75mm filament.

# Groove crosssection area in mm².
variable_groove_csa: 5.3

############################################################################################################ 
### Ejection.

# How long it takes to actuate the servo all the way.
# A MG90S servo is usually rated at 1.8ms/deg at 4.8V.
# Add some margin. For example 1.8ms*180 = 324ms -> 400ms.
variable_servo_dwell: 400

# How many actuations. Sometimes the pellet get stuck or missplaced, and
# another ejection fixes it.
variable_ejection_count: 3

############################################################################################################ 
### General.

# Z limit. Below this height, refuses to do anything as a safety measure.
# The check can be turned off by passing ZCHECK=0 to the macros.
variable_z_min: 5

# Travel move speed in mm/s.
variable_travel_speed: 400



[gcode_macro BRUSH]
# This macro performs a brushing operation to clean the printer's nozzle.
#
# Parameters:
#   CLEAR=1       - Flag to clear away from the brush at the end (1 to enable, 0 to disable)
#   ZHOP=-1       - Z hop height in mm (positive value to enable)
#   ZCHECK=1      - Flag to check if Z is too low before the operation (1 to enable, 0 to disable)

gcode:
    {% set cfg = printer['gcode_macro _PURGE_CFG'] %}               # Configuration from _PURGE_CFG macro

    # Initializing parameters with default values or user inputs
    {% set clear = params.CLEAR|default(1)|int %}                   # Flag to clear after brushing
    {% set zhop = params.ZHOP|default(-1)|float %}                  # Z hop height
    {% set zcheck = params.ZCHECK|default(1)|int %}                 # Flag for Z position check

    # Retrieving configuration settings
    {% set tspeed = cfg.travel_speed * 60 %}                        # Travel speed calculation
    {% set wspeed = cfg.brush_speed * 60 %}                         # Brushing speed calculation
    {% set sx = cfg.brush_start[0] %}                               # X coordinate of brush start
    {% set sy = cfg.brush_start[1] %}                               # Y coordinate of brush start

    # Error checking for printer state
    {% if "xyz" not in printer.toolhead.homed_axes %}
        { action_raise_error("EAP: Not homed") }    # Error if printer is not homed
    {% elif zcheck and printer.toolhead.position.z < cfg.z_min %}
        { action_raise_error("EAP: Z too low") }    # Error if Z position is too low
    {% else %}
        # Saving the current G-code state
        SAVE_GCODE_STATE NAME=EAP_BRUSH

        # Applying Z hop if enabled
        {% if zhop >= 0.0 %}
            G91  # Set to relative positioning
            G0 Z{zhop} F{tspeed}  # Z hop move
        {% endif %}

        # Moving to the brush start position
        G90  # Set to absolute positioning
        G0 X{sx} Y{sy} F{tspeed}  # Move to start of brush

        # Performing the brushing operation
        {% for _ in range(0, cfg.brush_count) %}
            G0 X{sx + cfg.brush_stroke} F{wspeed}  # Stroke forward
            G0 X{sx} F{wspeed}                      # Stroke backward
        {% endfor %}

        # Clearing move if enabled
        {% if clear == 1 %}
            G0 X{sx + cfg.brush_clear} F{tspeed}  # Clearing move
        {% endif %}

        # Restoring Z position if Z hop was used
        {% if zhop >= 0.0 %}
            G91  # Set to relative positioning
            G0 Z{-zhop} F{tspeed}  # Return to original Z position
        {% endif %}

        # Restoring the saved G-code state
        RESTORE_GCODE_STATE NAME=EAP_BRUSH
    {% endif %}


[gcode_macro PURGE]
# Eject the previous purge, then purge and plow through the brush.
#
# Parameters:
#   VOL=cfg.volume                - Purge volume in mm³ (default is set in _PURGE_CFG)
#   FLOW=cfg.flowrate             - Purging flow rate in mm³/s (default is set in _PURGE_CFG)
#   RET=cfg.retraction            - Retraction amount in mm³ (default is set in _PURGE_CFG)
#   RETSPEED=cfg.retraction_speed - Retraction speed in mm/s (default is set in _PURGE_CFG)
#   BRUSH_CLEAR=1                 - Flag to clear away from the brush at the end (1 to enable, 0 to disable)
#   EJECT=1                       - Flag to call PURGE_HOME before purging (1 to enable, 0 to disable)
#   ZHOP=-1                       - Z hop height in mm (positive value to enable)
#   ZCHECK=1                      - Flag to check if Z is too low (1 to enable, 0 to disable)
#
# Maximum purge volume: abs(groove_len) * groove_csa.
# Example: 35mm * 5.3mm³ == 185mm³

variable_last_purge: 0.0

gcode:
    {% set cfg = printer['gcode_macro _PURGE_CFG'] %}                                               # Configuration from _PURGE_CFG macro
    MMU_SERVO POS=up                                                                                # Ensure the MMU servo is in the up position

    # Setting up default values or user inputs
    {% set vol = params.VOL|default(cfg.volume)|float %}                                            # Purge volume in mm³
    {% set flow = params.FLOW|default(cfg.flowrate)|float %}                                        # Purging flow rate in mm³/s
    {% set retvol = params.RET|default(cfg.retraction)|float %}                                     # Retraction volume in mm³
    {% set retspeed = params.RETSPEED|default(cfg.retraction_speed)|float %}                        # Retraction speed in mm/s
    {% set brush_clear = params.BRUSH_CLEAR|default(1)|int %}                                       # Flag for clearing brush
    {% set eject = params.EJECT|default(1)|int %}                                                   # Flag for calling PURGE_HOME
    {% set zhop = params.ZHOP|default(-1)|float %}                                                  # Z hop height
    {% set zcheck = params.ZCHECK|default(1)|int %}                                                 # Flag for checking Z position

    # Calculating essential parameters
    {% set tspeed = cfg.travel_speed * 60 %}                                                        # Travel speed calculation
    {% set max_vol = (cfg.groove_len|abs * cfg.groove_csa) %}                                       # Maximum purge volume calculation
    {% set sx = cfg.groove_start[0] %}                                                              # X coordinate of purge start
    {% set sy = cfg.groove_start[1] %}                                                              # Y coordinate of purge start
    {% set initial_fan_speed = printer.fan.speed / printer.configfile.settings.fan.max_power %}     # Initial fan speed calculation
    {% set from_tool = printer.mmu.last_tool %}                                                     # Previous tool number
    {% set to_tool = printer.mmu.tool %}                                                            # Current tool number
    {% set pv = printer.mmu.slicer_tool_map.purge_volumes %}                                        # Purge volumes from slicer


    # Determining purge length
    {% if params.PURGE_LENGTH %}
        {action_respond_info("EAP: param PURGE_LENGTH provided")}
        {% set purge_len = params.PURGE_LENGTH|float %}
    {% elif from_tool == to_tool %}
        {action_respond_info("EAP: Tool didn't change (T%s > T%s), " ~ "priming" if cfg.purge_length_minimum else "skipping"  % (from_tool, to_tool))}
        {% set purge_len = 0 %}
    {% elif pv %}
        # Fetching purge volume from slicer
        {% if from_tool < 0 and to_tool >= 0 %}
            {action_respond_info("EAP: from tool unknown. Finding largest value for T? > T%d" % to_tool)}
            {% set purge_vol = pv|map(attribute=to_tool)|max %}
        {% elif to_tool < 0 %}
            {action_respond_info("EAP: tool(s) unknown. Finding largest value")}
            {% set purge_vol = pv|map('max')|max %}
        {% else %}
            {% set purge_vol = pv[from_tool][to_tool]|float * cfg.purge_length_modifier %}
            {action_respond_info("EAP: Swapped T%s > T%s" % (from_tool, to_tool))}
        {% endif %}
        {% set purge_len = purge_vol / cfg.groove_csa + cfg.purge_length_addition %}
    {% else %}
        {action_respond_info("EAP: No toolmap or PURGE_LENGTH. Using default")}
        {% set purge_len = vol|float %}
    {% endif %}
    {% set purge_len = [purge_len,cfg.purge_length_minimum]|max %}
    {action_respond_info("EAP: Purging %.2fmm of filament" % (purge_len|float))}

    # Error checking
    {% if "xyz" not in printer.toolhead.homed_axes %}
        { action_raise_error("EAP: Not homed") }
    {% elif zcheck and printer.toolhead.position.z < cfg.z_min %}
        { action_raise_error("EAP: Z too low") }
    {% elif purge_len > max_vol %}
        { action_raise_error("EAP: Purge volume %.3fmm³ greater than maximum %.3fmm³" % (purge_len, max_vol)) }
    {% else %}

        # Purging process
        SAVE_GCODE_STATE NAME=EAP_PURGE
        {% if zhop >= 0.0 %}
            G91 # Relative positioning
            G0 Z{zhop} F{tspeed} # Z hop move
        {% endif %}
        G90 # Absolute positioning
        {% if eject %}
            PURGE_HOME ZCHECK={zcheck}
        {% else %}
            G0 X{sx} Y{sy} F{tspeed} # Move to start of purge
        {% endif %}
        M106 S125 # Fan speed setting
        M83 # Extruder to relative mode
        {% set dist = purge_len / cfg.groove_csa %}
        {% set feed = flow / cfg.groove_csa %}
        {% set fil = purge_len / cfg.fil_csa %}
        {action_respond_info("purge: vol=%.3fmm3 flow=%.3fmm3/s dist=%.3fmm fil=%.3fmm rate=%.3fmm/s" % (purge_len, flow, dist, fil, feed))}
        G1 X{sx + dist} E{fil} F{feed * 60} # Purging
        {% set ret_fil = retvol / cfg.fil_csa %}
        G1 E-{ret_fil} F{retspeed * 60} # Retraction
        # Add a configurable pause here
        G0 X{cfg.brush_start[0]} Y{cfg.brush_start[1]} F{cfg.brush_speed * 60} # Move to brush start
        M106 S{initial_fan_speed * 255|int} # Reset fan speed
        {% if brush_clear == 1 %}
            G0 X{cfg.brush_start[0] + cfg.brush_clear} F{tspeed} # Clear move
        {% endif %}
        {% if zhop >= 0.0 %}
            G91 # Relative positioning
            G0 Z-{zhop} F{tspeed} # Z hop back
        {% endif %}
        RESTORE_GCODE_STATE NAME=EAP_PURGE
    {% endif %}


[gcode_macro PURGE_HOME]
# This macro positions the toolhead close to the ejection system, manages cooling,
# ejects the pellet, and then positions the toolhead above the purging groove.
# It also manages the fan state during this process.
#
# Example of use in PrusaSlicer tool change G-code:
#    {if has_wipe_tower}
#    T{next_extruder} ; ERCF swap { filament_preset[current_extruder] }
#    {else}
#    PURGE_HOME ZHOP=0.2 ZCHECK=0
#    T{next_extruder} ; ERCF swap { filament_preset[current_extruder] }
#    PURGE VOL=150 RET=0.5 RETSPEED=35 EJECT=0 BRUSH_CLEAR=0 ZCHECK=0
#    {endif}
#
# Parameters:
#   ZHOP=-1       - Z hop height in mm (positive value to enable)
#   ZCHECK=1      - Flag to check if Z is too low before the operation (1 to enable, 0 to disable)

gcode:
    {% set cfg = printer['gcode_macro _PURGE_CFG'] %}                                           # Retrieving configuration from _PURGE_CFG macro

    # Initializing parameters with default values or user inputs
    {% set zhop = params.ZHOP|default(-1)|float %}                                              # Z hop height
    {% set zcheck = params.ZCHECK|default(1)|int %}                                             # Flag for Z position check

    # Retrieving configuration and macro settings
    {% set mp = printer['gcode_macro PURGE'] %}
    {% set tspeed = cfg.travel_speed * 60 %}                                                    # Travel speed calculation
    {% set sx = cfg.groove_start[0] %}                                                          # X coordinate of purging start
    {% set sy = cfg.groove_start[1] %}                                                          # Y coordinate of purging start
    {% set cx = sx + cfg.cooling_pos[0] %}                                                      # X coordinate of cooling position
    {% set cy = sy + cfg.cooling_pos[1] %}                                                      # Y coordinate of cooling position
    {% set initial_fan_speed = printer.fan.speed / printer.configfile.settings.fan.max_power %} # Initial fan speed calculation

    # Error checking for printer state
    {% if "xyz" not in printer.toolhead.homed_axes %}
        { action_raise_error("EAP: Not homed") }  # Error if printer is not homed
    {% elif zcheck and printer.toolhead.position.z < cfg.z_min %}
        { action_raise_error("EAP: Z too low") }  # Error if Z position is too low
    {% else %}
        # Saving the current G-code state
        SAVE_GCODE_STATE NAME=EAP_PURGE_HOME

        # Applying Z hop if enabled
        {% if zhop >= 0.0 %}
            G91  # Set to relative positioning
            G0 Z{zhop} F{tspeed}  # Z hop move
        {% endif %}

        # Moving to the cooling position
        G90  # Set to absolute positioning
        G0 X{cx} Y{cy} F{tspeed}  # Move to cooling position
        M106 S125  # Turning on the fan (OBS: CHECK VARIABLE USAGE)

        # Waiting for the cooling period if necessary
        {% if printer.idle_timeout.state == "Printing" %}
            {% set elapsed = printer.idle_timeout.printing_time - mp.last_purge %}
            {% if elapsed > 0.0 and elapsed < cfg.cooling_period %}
                { action_respond_info("EAP: Waiting for pellet to cool...") }
                G4 P{cfg.cooling_period - elapsed}  # Pause for remaining cooling time
            {% endif %}
        {% endif %} 
        SET_GCODE_VARIABLE MACRO=PURGE VARIABLE=last_purge VALUE={printer.idle_timeout.printing_time}

        # Ejecting the pellet
        PURGE_EJECT

        # Moving to the purging position
        G0 X{sx} Y{sy} F{tspeed}  # Move to purging start position

        # Restoring Z position if Z hop was used
        {% if zhop >= 0.0 %}
            G91  # Set to relative positioning
            G0 Z{-zhop} F{tspeed}  # Return to original Z position
        {% endif %}

        M106 S{initial_fan_speed * 255|int}  # Restoring the fan speed to its initial state
        
        # Restoring the saved G-code state
        RESTORE_GCODE_STATE NAME=EAP_PURGE_HOME
    {% endif %}

[gcode_macro PURGE_EJECT]
description: Eject
# This macro is responsible for ejecting the pellet in the 3D printer.
#
# Async ejection state tracking:
#  -1: unknown
#   0: closed
#   1: opening
#   2: closing
#
# TODO: Awaiting implementation of async G-code synced to print time in Klipper for truly asynchronous operation.

# Declaration of global variables to track the state and stroke count
variable_e_state: -1  # Tracks the current ejection state (-1: unknown, 0: closed, 1: opening, 2: closing)
variable_e_stroke: 0  # Tracks the number of ejection strokes

gcode:
    # Retrieving configuration from _PURGE_CFG macro
    {% set cfg = printer['gcode_macro _PURGE_CFG'] %}

    # Retrieving configuration settings for ejection
    {% set dwell_s = cfg.servo_dwell / 1000 %}                              # Servo dwell time in seconds

    # Determining the state of the ejection mechanism
    {% if e_state == -1 %}  # State is unknown
        # Unknown state: Initiate opening with an extra half-stroke for safety
        SET_GCODE_VARIABLE MACRO=PURGE_EJECT VARIABLE=e_state VALUE=1       # Setting state to opening
    {% else %}
        # Known state: Proceed to closing the ejection mechanism
        # PURGE_EJECT_WAIT
        SET_GCODE_VARIABLE MACRO=PURGE_EJECT VARIABLE=e_state VALUE=2       # Setting state to closing
    {% endif %}

    # Setting the stroke variable to the configured ejection count
    SET_GCODE_VARIABLE MACRO=PURGE_EJECT VARIABLE=e_stroke VALUE={cfg.ejection_count}

    # Executing the wait function for the ejection process
    _PURGE_EJECT_WAIT  # Calls a sub-macro to handle the waiting process


[gcode_macro _PURGE_EJECT_WAIT]
description: Wait for the last ejection to complete
# This macro waits for the completion of the last pellet ejection process.
# It's used in tandem with the PURGE_EJECT macro to manage the ejection state machine.

gcode:
    # Retrieving configuration settings and ejection state
    {% set cfg = printer['gcode_macro _PURGE_CFG'] %}                           # Configuration from _PURGE_CFG macro
    {% set mp = printer['gcode_macro PURGE_EJECT'] %}                           # Accessing the PURGE_EJECT macro state

    # Checking if the ejection state indicates an ongoing process
    {% if mp.e_state > 0 %}  # State > 0 means ejection is ongoing
        # Calculating the dwell time for the servo mechanism
        {% set dwell_ms = cfg.servo_dwell %}  # Dwell time in milliseconds

        # Cancelling any previous scheduled delayed G-code
        UPDATE_DELAYED_GCODE ID=purge_ejection DURATION=0.0  # Cancels any existing delay

        # Waiting for the duration of the dwell time
        # Ensures completion of the current ejection step
        G4 P{dwell_ms|int}  # Pause (dwell) for the specified milliseconds

        # Calculating steps for the state machine
        # Accounts for opening, closing, and turnoff steps
        {% set steps = mp.e_stroke * 2 + (mp.e_state == 1)|int + 1 %}           # Total steps to complete cycle

        # Driving the state machine to completion
        {% for _ in range(steps) %}
            _PURGE_EJECTION_NEXT SYNC=1  # Advances to the next step in the state machine
        {% endfor %}
    {% endif %}  # End of ejection state check


[gcode_macro _PURGE_EJECTION_NEXT]
# Move the state machine forward
# This macro advances the ejection state machine, handling the servo's opening and closing actions during the pellet ejection process.
gcode:
    # Retrieving configuration settings from _PURGE_CFG macro
    {% set cfg = printer['gcode_macro _PURGE_CFG'] %}

    # Setting up synchronization parameter for sequence control
    {% set sync = params.SYNC|int %}                                 # Parameter to ensure actions follow in sequence

    # Accessing the state and control variables from PURGE_EJECT macro
    {% set mp = printer['gcode_macro PURGE_EJECT'] %}
    {% set done = false %}                                          # Flag to indicate completion of the state machine process

    # Debugging: Display current ejection state and stroke count
    #{ action_respond_info("%s %s" % (mp.e_state, mp.e_stroke)) }

    # Handling the ejection state machine based on current state
    {% if mp.e_state == 1 %}  # State 'opening'
        # Transitioning from opened to closed state
        SET_SERVO SERVO=eap_servo ANGLE=0  # Close servo
        SET_GCODE_VARIABLE MACRO=PURGE_EJECT VARIABLE=e_state VALUE=2  # Update state to 'closing'

    {% elif mp.e_state == 2 %}  # State 'closing'
        {% if mp.e_stroke > 0 %}
            # Transitioning from closed to open state for another stroke
            SET_SERVO SERVO=eap_servo ANGLE=180  # Open servo
            # Decrement stroke count and update state to 'opening'
            SET_GCODE_VARIABLE MACRO=PURGE_EJECT VARIABLE=e_stroke VALUE={mp.e_stroke - 1}
            SET_GCODE_VARIABLE MACRO=PURGE_EJECT VARIABLE=e_state VALUE=1

        {% else %}
            # No more strokes left, turn off the servo and set state to 'closed'
            SET_SERVO SERVO=eap_servo WIDTH=0  # Turn off servo
            SET_GCODE_VARIABLE MACRO=PURGE_EJECT VARIABLE=e_state VALUE=0  # Set state to closed
            {% set done = true %}  # Mark the process as done

        {% endif %}

    {% else %}  # State unknown or already closed
        # Invalid state: Raise an error
        { action_raise_error("EAP: invalid state %d" % mp.e_state) }
    {% endif %}

    # Managing servo movement delay based on synchronization setting
    {% if not done %}
        {% if sync %}
            # Synchronous waiting for servo to reach position
            G4 P{cfg.servo_dwell}  # Dwell for servo movement
        {% else %}
            # Asynchronous waiting for servo to reach position
            UPDATE_DELAYED_GCODE ID=purge_ejection DURATION={cfg.servo_dwell/1000}
        {% endif %}
    {% endif %}  # End of servo movement handling


[delayed_gcode purge_ejection]
# Asynchronous advancement of the ejection state machine
# This delayed G-code is responsible for asynchronously advancing the ejection state machine.
# It is triggered after a predefined delay and calls the _PURGE_EJECTION_NEXT macro 
# with the SYNC parameter set to 0, indicating an asynchronous operation.

gcode:
    _PURGE_EJECTION_NEXT SYNC=0